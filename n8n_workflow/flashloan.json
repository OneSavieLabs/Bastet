{
  "name": "flashloan",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "d798e549-8950-44e4-bf1f-4f4140885454",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -784,
        -64
      ],
      "id": "60bc2748-4ce4-4360-a2da-853ce2066394",
      "name": "Webhook",
      "webhookId": "d798e549-8950-44e4-bf1f-4f4140885454"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "162cf072-03ec-49a2-b87d-820eb155c89e",
              "leftValue": "={{ $json.body.mode }}",
              "rightValue": "trace",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -560,
        -64
      ],
      "id": "c832122f-2cf4-404f-a820-43da9f5c5100",
      "name": "If"
    },
    {
      "parameters": {
        "respondWith": "text",
        "responseBody": "={{ $execution.id }}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        -320,
        -176
      ],
      "id": "5fb5a7d9-d507-4696-877a-c88f89068109",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "72ea9720-b7d8-4e8c-9b6f-3a10987c34bf",
              "name": "chatInput",
              "value": "={{ $json.body.prompt }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -96,
        -48
      ],
      "id": "0dcdaf8e-08d9-48c1-9073-241dc6cfd1fc",
      "name": "Edit Fields"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "os-azure-gpt5-chat",
          "mode": "list",
          "cachedResultName": "os-azure-gpt5-chat"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        192,
        -32
      ],
      "id": "dbd01027-7878-439e-b5b5-1c89a3285ff5",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "1Wz24zrlSGOi0gdL",
          "name": "OpenAI Credentials"
        }
      }
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"type\": \"array\",\n  \"items\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"summary\": {\n        \"type\": \"string\",\n        \"description\": \"Brief summary of the vulnerability\"\n      },\n      \"severity\": {\n        \"type\": \"string\",\n        \"items\": {\n          \"type\": \"string\",\n          \"enum\": [\"high\", \"medium\", \"low\"]\n        },\n        \"description\": \"Severity level of the vulnerability\"\n      },\n      \"vulnerability_details\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"function_name\": {\n            \"type\": \"string\",\n            \"description\": \"Function name where the vulnerability is found\"\n          },\n          \"description\": {\n            \"type\": \"string\",\n            \"description\": \"Detailed description of the vulnerability\"\n          }\n        },\n        \"required\": [\"function_name\", \"description\"]\n      },\n      \"code_snippet\": {\n        \"type\": \"array\",\n        \"items\": {\n          \"type\": \"string\"\n        },\n        \"description\": \"Code snippet showing the vulnerability\",\n        \"default\": []\n      },\n      \"recommendation\": {\n        \"type\": \"string\",\n        \"description\": \"Recommendation to fix the vulnerability\"\n      }\n    },\n    \"required\": [\"summary\", \"severity\", \"vulnerability_details\", \"code_snippet\", \"recommendation\"]\n  },\n  \"additionalProperties\": false\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.2,
      "position": [
        384,
        -32
      ],
      "id": "7b22e798-6bbb-4d74-9081-bde863d591d7",
      "name": "Structured Output Parser"
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "3cc6b065-848f-45c9-af21-974d6de59d36",
      "name": "When chat message received",
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.1,
      "position": [
        -96,
        160
      ],
      "webhookId": "471f4f97-1fd4-4312-b3ee-6fcc3310611d"
    },
    {
      "parameters": {
        "numberInputs": 3
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        640,
        -32
      ],
      "id": "509acd36-3a2f-49ea-b007-711980da37dc",
      "name": "Merge"
    },
    {
      "parameters": {
        "respondWith": "allIncomingItems",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        864,
        -32
      ],
      "id": "6bcd6cae-4821-4997-8fef-6bf42033b81b",
      "name": "Respond to Webhook1"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=## Overview\n\nYou are a smart contract security auditor. After reading the following knowledge about flashloan manipulation vulnerability, follow the thinking process to detect the problem in the contract code. You will focus on the specific vulnerability - manipulation\n\n## Vulnerability description\n\nReward allocation must reflect **continuous stake commitment**, not instantaneous capital.  \nIf rewards depend solely on the current balance at claim time or at a single update tick, flash loans or short-term liquidity bursts can artificially boost the reward share.\n\nTherefore, reward calculation must depend on **time in stake**, **historical state**, or require **multi-block exposure**.\n\nLast but not least, there should be a instant claim/withdraw/redeem/distribute method here to fulfill the condition of using flashloan and the dependent asset of calculating incentive should be available for flashloan, for NFTs or any other non-transferrable assets, it will not count as suffering from flashloan manipulation vulnerability.\n\nIf not all condition is fulfilled, there's no flashloan manipulation vulnerability.\n\t\t    \n## Thinking Process\n\n1. First, identify if a function related to incentive calculation\n   - Search for all functions that\n\t   - Reward = function of current liquidity\n\t   - Reward = function of current deposited amount\n\t   - Snapshot-based staking / LP share\n\t   - Borrowing incentives\n\t   - Points / mining systems relying on non-time-weighted metrics\n\t   - Using instant spot price, getting spot price from AMM instead of TWAP\n\t- Whether the incentives are calculated by a flashloanable assets like BTC/ETH or any other thing else.\n\n\tIf no function related to incentive calculation, there's no potential vulnerability.\n\n2. If yes to any above, examine the statement of the function:\n    - Is there any if statement to seperate prevent flashloan attack from happening.\n    \t- Time-weighted accrual: incentives scale with time in stake.\n    \t- Minimum stake / lock duration: User must satisfy a minimum duration before full incentive eligibility\n    \t- Cliff or vesting: Incentives vest over time. Short-term users receive reduced or zero incentives if they exit early.\n    \t- Epoch snapshots: Incentive weights are based on user balances at a defined point:\n\t\t     - Epoch start or a snapshot block.\n\t\t     - Use patterns like:\n\t\t       - `balanceOfAt(user, epochSnapshotBlock)`.\n\t\t- Guarding against “just-in-time” deposits:\n\t\t\t- If distribution uses snapshot at time `T`, deposits after `T` must not count for that epoch’s incentive.\n\t\t\t- Check logic that explicitly excludes late joiners for the current incentive period.\n\t\t- Flash-loan-specific defenses \n\t\t\t- If deposit and withdrawal happen in the same block / transaction:\n\t\t\t    - Either incentives for that block are zero or the position is treated as not staked for incentive purposes.\n\t\t- Entry → accrue → exit atomicity\n\t\t\t- Check feasibility of a single-tx path:\n    \t\t\t- `flashLoan → deposit/stake → trigger reward update/distribution → withdraw → repay`.\n    \t\t- Reward updates ignore positions opened in the same block.\n     \t\t- Withdrawals in the same block lose eligibility for that period’s rewards.\n\t\t- Valuation sanity checks (for LP / oracle-based weights)\n\t\t\t- If reward weight uses LP value or oracle prices:\n\t\t\t    - Use **TWAP** instead of spot.\n\t\t\t    - Enforce reserve sanity checks.\n\t\t\t    - Cap reward weight per LP share / per user.\n\t\t-  Adding a delay / cooldown to critical action like mint/redeem, borrow/liquidate, reward claim\n\n3. If non of the function statement fulfill, keep going to find\n    - Is there any function related to reward claim/withdraw/redeem/distribute? If so, can it be done instantly?\n    - The deposit assets should return at the end of the transactions. The assets should remain the same to finish a flashloan\n\nIf all of the condition fulfilled and can be claimed instantly, this is a potential vulnerability of flashloan manipulation attack\n\n\n## Examples with Reasoning\n\n### Example : Reward = function of current liquidity\n\n```\nmapping(address => uint256) public lpBalance;\nuint256 public totalLP;\nuint256 public rewardPool;\n\nfunction provideLiquidity(uint256 amount) external {\n    lpToken.transferFrom(msg.sender, address(this), amount);\n    lpBalance[msg.sender] += amount;\n    totalLP += amount;\n}\n\nfunction withdrawLiquidity(uint256 amount) external {\n    lpBalance[msg.sender] -= amount;\n    totalLP -= amount;\n    lpToken.transfer(msg.sender, amount);\n}\n\nfunction distributeReward() external {\n    uint256 reward = (lpBalance[msg.sender] * rewardPool) / totalLP;\n    rewardToken.mint(msg.sender, reward);\n}\n```\n\nThought process:\n\n1. This is a function related to incentive calculation, and the reward is related to current liquidity (`uint256 totalLP = lpToken.totalSupply();`)\n\n2. No protection behavior here.\n3. There is a instant withdraw function.\n\nall of the condition fulfilled -> suffer from flashloan manipulation vulnerability\n\n### Example: Reward = function of current deposited amount\n\n```\nmapping(address => uint256) public deposits;\nuint256 public totalDeposited;\nuint256 public rewardPerEpoch;\n\nfunction deposit(uint256 amount) external {\n    token.transferFrom(msg.sender, address(this), amount);\n    deposits[msg.sender] += amount;\n    totalDeposited += amount;\n}\n\nfunction withdraw(uint256 amount) external {\n    deposits[msg.sender] -= amount;\n    totalDeposited -= amount;\n    token.transfer(msg.sender, amount);\n}\n\nfunction claim() external {\n    uint256 reward = (deposits[msg.sender] * rewardPerEpoch) / totalDeposited;\n    rewardToken.transfer(msg.sender, reward);\n}\n```\n\nThought process:\n\n1. This is a function related to incentive calculation, and the incentive is related to current deposited amount (`uint256 userDeposit = deposits[msg.sender];`)\n\n2. No protection behavior here.\n\n3. There is a instant claim/withdraw/redeem/distribute function.\n\nall of the condition fulfilled -> suffer from flashloan manipulation vulnerability\n\n\n### Example: Snapshot-based staking / LP share\n\n```\nmapping(address => uint256) public stakeBalance;\nuint256 public totalStake;\n\nmapping(address => uint256) public snapshotUser;\nuint256 public snapshotTotal;\nuint256 public totalReward;\n\nfunction stake(uint256 amount) external {\n    stakeToken.transferFrom(msg.sender, address(this), amount);\n    stakeBalance[msg.sender] += amount;\n    totalStake += amount;\n}\n\nfunction withdraw(uint256 amount) external {\n    stakeBalance[msg.sender] -= amount;\n    totalStake -= amount;\n    stakeToken.transfer(msg.sender, amount);\n}\n\nfunction takeSnapshot() external {\n    snapshotTotal = totalStake;\n    snapshotUser[msg.sender] = stakeBalance[msg.sender];\n}\n\nfunction claimSnapshotReward() external {\n    uint256 reward = (snapshotUser[msg.sender] * totalReward) / snapshotTotal;\n    rewardToken.mint(msg.sender, reward);\n}\n\n```\n\nThought process:\n\n1. This is a function related to incentive calculation, and the incentive is related to Snapshot-based staking (`snapshotTotal = stakingToken.totalSupply();`)\n\n2. No protection behavior here.\n\n3. There is a instant withdraw function.\n\nall of the condition fulfilled -> suffer from flashloan manipulation vulnerability\n\n\n### Example: Borrowing incentives (flash-loan boosted borrow)\n\n```\nmapping(address => uint256) public borrowedAmount;\nuint256 public borrowRewardRate;\n\nfunction borrow(uint256 amount) external {\n    borrowedAmount[msg.sender] += amount;\n    debtToken.transfer(msg.sender, amount);\n}\n\nfunction repay(uint256 amount) external {\n    borrowedAmount[msg.sender] -= amount;\n    debtToken.transferFrom(msg.sender, address(this), amount);\n}\n\nfunction claimBorrowReward() external {\n    uint256 reward = borrowedAmount[msg.sender] * borrowRewardRate;\n    rewardToken.mint(msg.sender, reward);\n}\n\n```\n\nThought process:\n\n1. This is a function related to incentive calculation, and the incentive is related to borrowing incentives (`suint256 borrowed = borrowedAmount[msg.sender];`)\n\n2. No protection behavior here.\n\n3. There is a instant withdraw function.\n\nall of the condition fulfilled -> suffer from flashloan manipulation vulnerability\n\n\n### Example: Points / mining systems relying on non-time-weighted metrics\n\n```\nmapping(address => uint256) public balances;\nuint256 public totalStakes;\nmapping(address => uint256) public userPoints;\nuint256 public epochPoints;\n\nfunction stake(uint256 amount) external {\n    token.transferFrom(msg.sender, address(this), amount);\n    balances[msg.sender] += amount;\n    totalStakes += amount;\n}\n\nfunction withdraw(uint256 amount) external {\n    balances[msg.sender] -= amount;\n    totalStakes -= amount;\n    token.transfer(msg.sender, amount);\n}\n\nfunction updatePoints(address user) external {\n    uint256 points = (balances[user] * epochPoints) / totalStakes;\n    userPoints[user] += points;\n}\n\n```\n\n\nThought process:\n\n1. This is a function related to incentive calculation, and the incentive is related to points / mining systems relying on non-time-weighted metrics (`uint256 stake = balances[user];`)\n\n2. No protection behavior here.\n\n3. There is a instant withdraw function.\n\nall of the condition fulfilled -> suffer from flashloan manipulation vulnerability\n\n\n## Report Format\n\nIf the input is not a smart contracts, report with a empty array:\n\n\n[]\n\n\nIf the conclusion of a function is “No vulnerability”, report with a empty array:\n\n\n[]\n\n\nIf vulnerabilities found in a function, report with a json:\n\n\n[\n    {\n        \"summary\":  \"summary of the vulnerability\",\n        \"severity\": \"how severe is the vulnerability\"\n        \"vulnerability_details\": {\n            \"Function Name\": \"Name of the function\",\n            \"Description\": \"a brief description of the vulnerability\"\n        },\n        \"code_snippet\": \"where the vulnerability happen\"\n    \t\"recommendation\": \"how to fix this vulnerability\"\n    }\n]"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.5,
      "position": [
        208,
        -224
      ],
      "id": "84dbcb31-b0c7-4814-9093-fdc32c939da0",
      "name": "COT - flashloan manipulation attack",
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Respond to Webhook": {
      "main": [
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "COT - flashloan manipulation attack",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "COT - flashloan manipulation attack",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields": {
      "main": [
        [
          {
            "node": "COT - flashloan manipulation attack",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When chat message received": {
      "main": [
        [
          {
            "node": "COT - flashloan manipulation attack",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Respond to Webhook1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "COT - flashloan manipulation attack": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 2
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "99226f54-9589-494a-b683-9b1c9b4ffb16",
  "meta": {
    "instanceId": "f839b7ae33d4bab8c0e6053fad2787e1ad0bd33854a965624f05316a09f93d09"
  },
  "id": "tzkhlCrrJgtL7ICg",
  "tags": []
}